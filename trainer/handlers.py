import logging
import random
import asyncio
from aiogram import Dispatcher, types, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from .keyboards import get_nickname_keyboard
from .texts import (
    RULES_TEXT, TIPS_TEXT, START_FIGHT_PHRASES, TIMED_FIGHT_START_PHRASES, TIMED_FIGHT_END_PHRASES,
    TIMED_FIGHT_TIMEOUT_PHRASE, TIMED_FIGHT_TICK_PHRASES, CONTROL_SUCCESS_PHRASES, CONTROL_FAIL_PHRASES,
    ATTACK_SUCCESS_PHRASES, ATTACK_FAIL_PHRASES, DEFENSE_CONTROL_SUCCESS_PHRASES, DEFENSE_CONTROL_FAIL_PHRASES,
    DEFENSE_ATTACK_SUCCESS_PHRASES, DEFENSE_ATTACK_FAIL_PHRASES, DRAW_PHRASES
)
from .state import FightState
from .data import save_fighter, save_fight, get_db_connection, DEFENSE_MOVES, MOVES
from .game_logic import check_defense

logger = logging.getLogger(__name__)

def get_start_button() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–°—Ç–∞—Ä—Ç", callback_data="start_button")]])

def get_fight_keyboard(is_timed=False) -> InlineKeyboardMarkup:
    buttons = [
        [InlineKeyboardButton(text="–ì–µ–¥–∞–Ω –±–∞—Ä–∞–π", callback_data="defense_–ì–µ–¥–∞–Ω –±–∞—Ä–∞–π")],
        [InlineKeyboardButton(text="–ê–≥–µ —É–∫–µ", callback_data="defense_–ê–≥–µ —É–∫–µ")],
        [InlineKeyboardButton(text="–°–æ—Ç–æ —É–∫–µ", callback_data="defense_–°–æ—Ç–æ —É–∫–µ")],
        [InlineKeyboardButton(text="–£—á–∏ —É–∫–µ", callback_data="defense_–£—á–∏ —É–∫–µ")],
    ]
    if not is_timed:
        buttons.append([InlineKeyboardButton(text="üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞", callback_data="hint")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_main_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ë–æ–π ü•ä", callback_data="fight_menu")],
        [InlineKeyboardButton(text="–ü—Ä–æ—Ñ–∏–ª—å üìä", callback_data="show_profile")]
    ])

def get_profile_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ë–æ–π ü•ä", callback_data="fight_menu")],
        [InlineKeyboardButton(text="–°–º–µ–Ω–∏—Ç—å –Ω–∏–∫", callback_data="custom_nick")],
        [InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_main")]
    ])

def get_fight_modes_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ü—Ä–æ—Å—Ç–æ–π –±–æ–π", callback_data="simple_fight_menu")],
        [InlineKeyboardButton(text="–ë–æ–π –Ω–∞ –≤—Ä–µ–º—è", callback_data="timed_fight")],
        [InlineKeyboardButton(text="PvP —Å –±–æ—Ç–æ–º", callback_data="pvp_bot")],
        [InlineKeyboardButton(text="PvP –ê—Ä–µ–Ω–∞", callback_data="pvp_arena")],
        [InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_main")]
    ])

def get_simple_fight_menu(exclude=None) -> InlineKeyboardMarkup:
    buttons = [
        [InlineKeyboardButton(text="–ü—Ä–∞–≤–∏–ª–∞", callback_data="show_rules")],
        [InlineKeyboardButton(text="–ü–∞–º—è—Ç–∫–∞", callback_data="show_tips")],
        [InlineKeyboardButton(text="–ù–∞—á–∞—Ç—å –±–æ–π", callback_data="start_simple_fight")],
        [InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_fight_modes")]
    ]
    if exclude:
        buttons = [b for b in buttons if b[0].text != exclude]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

async def clear_keyboard(bot, chat_id, message_id, fight_id):
    for _ in range(2):
        try:
            await bot.edit_message_reply_markup(chat_id=chat_id, message_id=message_id, reply_markup=None)
            logger.info(f"Fight {fight_id}: Cleared keyboard for message {message_id}")
            return True
        except Exception as e:
            logger.warning(f"Fight {fight_id}: Failed to clear keyboard for message {message_id}: {e}")
            await asyncio.sleep(0.5)
    logger.error(f"Fight {fight_id}: Failed to clear keyboard for message {message_id} after retries")
    return False

async def timed_fight_timer(context: FSMContext, message: Message, user_id: int, step: int, fight_message: Message, fight_id: str):
    for seconds in range(4, -1, -1):
        user_data = await context.get_data()
        if user_data.get("fight_type") != "timed" or user_data.get("step") != step or not user_data.get("is_fighting"):
            logger.info(f"Fight {fight_id}: Timer stopped for step {step}")
            return
        tick_phrase = random.choice(TIMED_FIGHT_TICK_PHRASES).format(seconds=seconds)
        await fight_message.edit_text(
            f"‚öîÔ∏è <code>–°—Ö–≤–∞—Ç–∫–∞ {step}</code>\n\n"
            f"üéØ <i>–ö–æ–Ω—Ç—Ä–æ–ª—å</i>: <b>{user_data['current_move'][0]}</b>\n"
            f"üí• <i>–ê—Ç–∞–∫–∞</i>: <b>{user_data['current_move'][1]}</b>\n\n"
            f"–í—ã–±–µ—Ä–∏ –∑–∞—â–∏—Ç—É ({seconds} —Å–µ–∫):\n{tick_phrase}",
            parse_mode="HTML",
            reply_markup=get_fight_keyboard(is_timed=True)
        )
        await asyncio.sleep(1)
    user_data = await context.get_data()
    if user_data.get("fight_type") == "timed" and user_data.get("step") == step and user_data.get("is_fighting"):
        await context.update_data(is_fighting=False)
        stats = user_data.get("stats", {"wins": 0, "partial": 0, "losses": 0})
        score = user_data.get("score", 0)
        stats["losses"] += 1
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT fighter_name FROM users_dev WHERE user_id = %s", (user_id,))
        user_nick = cursor.fetchone()[0]
        cursor.close()
        conn.close()
        save_fight(user_id, "timed", score)
        if await clear_keyboard(message.bot, message.chat.id, fight_message.message_id, fight_id):
            await message.answer(TIMED_FIGHT_TIMEOUT_PHRASE, parse_mode="HTML")
            end_phrase = random.choice(TIMED_FIGHT_END_PHRASES)
            await message.answer(
                f"üèÜ <b>–ë–æ–π –Ω–∞ –≤—Ä–µ–º—è –∑–∞–≤–µ—Ä—à—ë–Ω!</b>\n"
                f"ü•ã {end_phrase}\n"
                f"‚≠ê <b>{user_nick}</b> –Ω–∞–±—Ä–∞–ª <code>–ë–∞–ª–ª—ã: {score}</code>",
                parse_mode="HTML"
            )
            await message.answer(
                f"<code>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—è</code>\n\n"
                f"<i>–°—Ö–≤–∞—Ç–æ–∫</i>: <b>{step}</b>\n"
                f"<i>–ß–∏—Å—Ç–∞—è –ø–æ–±–µ–¥–∞</i>: <b>{stats['wins']}</b>\n"
                f"<i>–ß–∞—Å—Ç–∏—á–Ω—ã–π —É—Å–ø–µ—Ö</i>: <b>{stats['partial']}</b>\n"
                f"<i>–ü–æ—Ä–∞–∂–µ–Ω–∏–µ</i>: <b>{stats['losses']}</b>",
                parse_mode="HTML",
                reply_markup=get_main_menu()
            )
        else:
            await message.answer("–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å –±–æ–π –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.", reply_markup=get_main_menu())
        await context.clear()

def setup_handlers(dp: Dispatcher):
    @dp.message(Command("start"))
    async def cmd_start(message: Message):
        await message.answer(
            f"ü•ã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ö–ê–†–ê–¢–≠ —Ç—Ä–µ–Ω–∞–∂–µ—Ä!</b>\n–ù–∞–∂–º–∏, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å:",
            parse_mode="HTML",
            reply_markup=get_start_button()
        )

    @dp.callback_query(F.data == "start_button")
    async def start_button(callback: CallbackQuery, state: FSMContext):
        username = callback.from_user.username or "Fighter"
        await callback.message.edit_text(
            f"ü•ã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ö–ê–†–ê–¢–≠ —Ç—Ä–µ–Ω–∞–∂–µ—Ä!</b>\n"
            f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–∞—à <b>–Ω–∏–∫ Telegram ({username})</b> –∏–ª–∏ <b>–≤—ã–±—Ä–∞—Ç—å —Å–≤–æ–π</b>?",
            parse_mode="HTML",
            reply_markup=get_nickname_keyboard()
        )
        await callback.answer()

    @dp.message(Command("menu"))
    async def cmd_menu(message: Message):
        await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_main_menu())

    @dp.message(Command("profile"))
    async def cmd_profile(message: Message):
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute(
                "SELECT fighter_name, life, strength, agility, spirit, belt "
                "FROM users_dev JOIN profiles_dev ON users_dev.user_id = profiles_dev.user_id "
                "WHERE users_dev.user_id = %s",
                (message.from_user.id,)
            )
            result = cursor.fetchone()
            if result:
                name, life, strength, agility, spirit, belt = result
                await message.answer(
                    f"üìä <b>–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å</b>\n"
                    f"–ò–º—è: <b>{name}</b>\n–ñ–∏–∑–Ω—å: <b>{life}</b> ‚ù§Ô∏è\n–°–∏–ª–∞: <b>{strength}</b> üí™\n"
                    f"–õ–æ–≤–∫–æ—Å—Ç—å: <b>{agility}</b> üåÄ\n–î—É—Ö: <b>{spirit}</b> ‚ú®\n–ü–æ—è—Å: <b>{belt}</b> üü°",
                    parse_mode="HTML",
                    reply_markup=get_profile_menu()
                )
            else:
                await message.answer("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        except Exception as e:
            logger.error(f"Profile fetch failed: {e}")
            await message.answer(f"–û—à–∏–±–∫–∞: {e}")
        finally:
            if conn:
                cursor.close()
                conn.close()

    @dp.callback_query(F.data == "use_telegram_nick")
    async def use_telegram_nick(callback: CallbackQuery, state: FSMContext):
        username = callback.from_user.username or f"User{callback.from_user.id}"
        user_id = callback.from_user.id
        try:
            save_fighter(user_id, username)
            await callback.message.edit_text(
                f"–ù–∏–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>{username}</b>! –ì–æ—Ç–æ–≤ –∫ –±–æ—é? üí™",
                parse_mode="HTML",
                reply_markup=get_main_menu()
            )
            await state.clear()
        except Exception as e:
            logger.error(f"Save fighter failed: {e}")
            await callback.message.edit_text(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
        await callback.answer()

    @dp.callback_query(F.data == "custom_nick")
    async def custom_nick(callback: CallbackQuery, state: FSMContext):
        await callback.message.edit_text("–í–≤–µ–¥–∏ —Å–≤–æ–π —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –Ω–∏–∫:")
        await state.set_state(FightState.waiting_for_name)
        await callback.answer()

    @dp.message(FightState.waiting_for_name)
    async def process_custom_nick(message: Message, state: FSMContext):
        nickname = message.text.strip()
        user_id = message.from_user.id
        try:
            save_fighter(user_id, nickname)
            await message.answer(
                f"–ù–∏–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>{nickname}</b>! –ì–æ—Ç–æ–≤ –∫ –±–æ—é? üí™",
                parse_mode="HTML",
                reply_markup=get_main_menu()
            )
            await state.clear()
        except Exception as e:
            logger.error(f"Save fighter failed: {e}")
            await message.answer(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
            await state.clear()

    @dp.callback_query(F.data == "fight_menu")
    async def fight_menu(callback: CallbackQuery, state: FSMContext):
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –±–æ—è:", reply_markup=get_fight_modes_menu())
        await callback.answer()

    @dp.callback_query(F.data == "simple_fight_menu")
    async def simple_fight_menu(callback: CallbackQuery):
        await callback.message.edit_text("–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π –±–æ–π!?", reply_markup=get_simple_fight_menu())
        await callback.answer()

    @dp.callback_query(F.data == "show_rules")
    async def show_rules(callback: CallbackQuery):
        await callback.message.edit_text(RULES_TEXT, parse_mode="HTML", reply_markup=get_simple_fight_menu(exclude="–ü—Ä–∞–≤–∏–ª–∞"))
        await callback.answer()

    @dp.callback_query(F.data == "show_tips")
    async def show_tips(callback: CallbackQuery):
        await callback.message.edit_text(TIPS_TEXT, parse_mode="HTML", reply_markup=get_simple_fight_menu(exclude="–ü–∞–º—è—Ç–∫–∞"))
        await callback.answer()

    @dp.callback_query(F.data == "timed_fight")
    async def timed_fight(callback: CallbackQuery, state: FSMContext):
        user_id = callback.from_user.id
        fight_id = f"{user_id}_{random.randint(1000, 9999)}"
        await state.update_data(
            fight_type="timed",
            is_fighting=True,
            is_processing=False,
            user_id=user_id,
            step=1,
            score=0,
            stats={"wins": 0, "partial": 0, "losses": 0},
            fight_sequence=random.sample(MOVES, 10),
            last_fight_message_id=None,
            fight_id=fight_id
        )
        start_phrase = random.choice(TIMED_FIGHT_START_PHRASES)
        await callback.message.edit_text(
            f"<b>–ë–æ–π –Ω–∞ –≤—Ä–µ–º—è –Ω–∞—á–∞–ª—Å—è!</b>\nü•ã {start_phrase}",
            parse_mode="HTML"
        )
        fight_data = await state.get_data()
        control, attack = fight_data["fight_sequence"][0]
        await state.update_data(current_move=(control, attack))
        fight_message = await callback.message.answer(
            f"‚öîÔ∏è <code>–°—Ö–≤–∞—Ç–∫–∞ 1</code>\n\n"
            f"üéØ <i>–ö–æ–Ω—Ç—Ä–æ–ª—å</i>: <b>{control}</b>\n"
            f"üí• <i>–ê—Ç–∞–∫–∞</i>: <b>{attack}</b>\n\n"
            f"–í—ã–±–µ—Ä–∏ –∑–∞—â–∏—Ç—É (5 —Å–µ–∫):",
            parse_mode="HTML",
            reply_markup=get_fight_keyboard(is_timed=True)
        )
        await state.update_data(last_fight_message_id=fight_message.message_id)
        asyncio.create_task(timed_fight_timer(state, callback.message, user_id, 1, fight_message, fight_id))
        await callback.answer()

    @dp.callback_query(F.data == "pvp_bot")
    async def pvp_bot(callback: CallbackQuery):
        await callback.message.edit_text(
            "PvP —Å –±–æ—Ç–æ–º –ø–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ! –°–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="fight_menu")]])
        )
        await callback.answer()

    @dp.callback_query(F.data == "pvp_arena")
    async def pvp_arena(callback: CallbackQuery):
        await callback.message.edit_text(
            "PvP –ê—Ä–µ–Ω–∞ –ø–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ! –°–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="fight_menu")]])
        )
        await callback.answer()

    @dp.callback_query(F.data == "back_to_main")
    async def back_to_main(callback: CallbackQuery):
        await callback.message.edit_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_main_menu())
        await callback.answer()

    @dp.callback_query(F.data == "back_to_fight_modes")
    async def back_to_fight_modes(callback: CallbackQuery):
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –±–æ—è:", reply_markup=get_fight_modes_menu())
        await callback.answer()

    @dp.callback_query(F.data == "start_simple_fight")
    async def start_simple_fight(callback: CallbackQuery, state: FSMContext):
        fight_id = f"{callback.from_user.id}_{random.randint(1000, 9999)}"
        await state.update_data(
            fight_sequence=random.sample(MOVES, 10),
            fight_type="simple",
            step=1,
            score=0,
            stats={"wins": 0, "partial": 0, "losses": 0, "hints": 0},
            last_fight_message_id=None,
            is_processing=False,
            fight_id=fight_id
        )
        fight_data = await state.get_data()
        control, attack = fight_data["fight_sequence"][0]
        start_phrase = random.choice(START_FIGHT_PHRASES)
        await callback.message.edit_text(
            f"<b>–ë–æ–π –Ω–∞—á–∞–ª—Å—è!</b>\nü•ã {start_phrase}",
            parse_mode="HTML"
        )
        fight_message = await callback.message.answer(
            f"‚öîÔ∏è <code>–°—Ö–≤–∞—Ç–∫–∞ 1 –∏–∑ 10</code>\n\n"
            f"üéØ <i>–ö–æ–Ω—Ç—Ä–æ–ª—å</i>: <b>{control}</b>\n"
            f"üí• <i>–ê—Ç–∞–∫–∞</i>: <b>{attack}</b>\n\n"
            f"–í—ã–±–µ—Ä–∏ –∑–∞—â–∏—Ç—É:",
            parse_mode="HTML",
            reply_markup=get_fight_keyboard()
        )
        await state.update_data(last_fight_message_id=fight_message.message_id)
        await callback.answer()

    @dp.callback_query(F.data.startswith("defense_"))
    async def process_defense(callback: CallbackQuery, state: FSMContext):
        fight_data = await state.get_data()
        fight_id = fight_data.get("fight_id", "unknown")
        if fight_data.get("is_processing"):
            logger.info(f"Fight {fight_id}: Ignored duplicate callback from user {callback.from_user.id}")
            await callback.answer()
            return
        await state.update_data(is_processing=True)
        try:
            defense = callback.data.replace("defense_", "")
            fight_type = fight_data.get("fight_type", "simple")
            step = fight_data.get("step", 1)
            score = fight_data.get("score", 0)
            stats = fight_data.get("stats", {"wins": 0, "partial": 0, "losses": 0, "hints": 0})
            is_fighting = fight_data.get("is_fighting", True)
            last_fight_message_id = fight_data.get("last_fight_message_id")

            if not is_fighting:
                await callback.message.edit_text("–ë–æ–π –∑–∞–≤–µ—Ä—à—ë–Ω!")
                await callback.answer()
                return

            sequence = fight_data.get("fight_sequence", MOVES)
            control, attack = sequence[step-1]

            points, result, correct_defenses, log = await check_defense(control, attack, defense)
            score += points
            if points == 3:
                stats["wins"] += 1
            elif points == 1:
                stats["partial"] += 1
            else:
                stats["losses"] += 1

            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT fighter_name FROM users_dev WHERE user_id = %s", (callback.from_user.id,))
            user_nick = cursor.fetchone()[0]
            cursor.close()
            conn.close()

            bot_nick = "–ë–æ—Ç –í–∞—Å—è"
            control_success = control in DEFENSE_MOVES.get(defense, {}).get("control_defense", [])
            attack_success = attack in DEFENSE_MOVES.get(defense, {}).get("attack_defense", [])

            target_map = {"–î–ó": "–≥–æ–ª–æ–≤—É", "–¢–†": "–≥—Ä—É–¥—å", "–°–°": "–∂–∏–≤–æ—Ç"}
            control_phrase = random.choice(
                CONTROL_FAIL_PHRASES[control] if control_success else CONTROL_SUCCESS_PHRASES[control]
            ).format(nick=bot_nick, target=target_map.get(control, control))

            defense_control_phrase = random.choice(
                DEFENSE_CONTROL_SUCCESS_PHRASES[control] if control_success else DEFENSE_CONTROL_FAIL_PHRASES[control]
            ).format(nick=user_nick, target=target_map.get(control, control))

            attack_target_map = {"–î–ó": "–ª–æ–±", "–¢–†": "–≥—Ä—É–¥—å", "–°–°": "–∂–∏–≤–æ—Ç", "–ì–î–ù": "–Ω–æ–≥–∏"}
            attack_phrase = random.choice(
                ATTACK_FAIL_PHRASES[attack] if attack_success else ATTACK_SUCCESS_PHRASES[attack]
            ).format(nick=bot_nick, target=attack_target_map.get(attack, attack))

            defense_attack_phrase = random.choice(
                DEFENSE_ATTACK_SUCCESS_PHRASES[attack] if attack_success else DEFENSE_ATTACK_FAIL_PHRASES[attack]
            ).format(nick=user_nick, target=attack_target_map.get(attack, attack))

            log_message = (
                f"‚öîÔ∏è {control_phrase} {'‚úÖ' if not control_success else '‚ùå'}\n"
                f"üõ°Ô∏è {defense_control_phrase} {'‚úÖ' if control_success else '‚ùå'}\n"
                f"üí• {attack_phrase} {'‚úÖ' if not attack_success else '‚ùå'}\n"
                f"üõ°Ô∏è {defense_attack_phrase} {'‚úÖ' if attack_success else '‚ùå'}"
            ).strip()

            await callback.message.edit_text(
                f"‚öîÔ∏è <code>–°—Ö–≤–∞—Ç–∫–∞ {step}</code>\n\n"
                f"üéØ <i>–ö–æ–Ω—Ç—Ä–æ–ª—å</i>: <b>{control}</b>\n"
                f"üí• <i>–ê—Ç–∞–∫–∞</i>: <b>{attack}</b>\n"
                f"üõ°Ô∏è <i>–ó–∞—â–∏—Ç–∞</i>: <b>{defense}</b>\n\n"
                f"<i>–†–µ–∑—É–ª—å—Ç–∞—Ç</i>: <b>{result}</b> (<b>+{points} –±–∞–ª–ª–æ–≤</b>)",
                parse_mode="HTML"
            )
            await callback.message.answer(log_message, parse_mode="HTML")

            # –û—á–∏—Å—Ç–∫–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã —Ç–µ–∫—É—â–µ–π —Å—Ö–≤–∞—Ç–∫–∏
            if last_fight_message_id:
                if not await clear_keyboard(callback.message.bot, callback.message.chat.id, last_fight_message_id, fight_id):
                    logger.error(f"Fight {fight_id}: Failed to proceed due to keyboard cleanup error")
                    await callback.message.answer("–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É.", reply_markup=get_main_menu())
                    await state.clear()
                    await callback.answer()
                    return

            if fight_type == "simple" and step >= 10 or fight_type == "timed" and step >= 10:
                user_id = callback.from_user.id
                save_fight(user_id, fight_type, score)
                await callback.message.answer(
                    f"üèÜ <b>–ë–æ–π –∑–∞–≤–µ—Ä—à—ë–Ω!</b>\n\n"
                    f"‚≠ê <b>{user_nick}</b> –Ω–∞–±—Ä–∞–ª <code>–ë–∞–ª–ª—ã: {score}</code>",
                    parse_mode="HTML"
                )
                draw_phrase = random.choice(DRAW_PHRASES) if score == 0 else ""
                if fight_type == "simple":
                    await callback.message.answer(
                        f"<code>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—è</code>\n\n"
                        f"<i>–ß–∏—Å—Ç–∞—è –ø–æ–±–µ–¥–∞</i>: <b>{stats['wins']}</b>\n"
                        f"<i>–ß–∞—Å—Ç–∏—á–Ω—ã–π —É—Å–ø–µ—Ö</i>: <b>{stats['partial']}</b>\n"
                        f"<i>–ü–æ—Ä–∞–∂–µ–Ω–∏–µ</i>: <b>{stats['losses']}</b>\n"
                        f"<i>–ü–æ–¥—Å–∫–∞–∑–æ–∫</i>: <b>{stats['hints']}</b>\n\n"
                        f"{draw_phrase}",
                        parse_mode="HTML",
                        reply_markup=get_main_menu()
                    )
                else:
                    await callback.message.answer(
                        f"<code>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—è</code>\n\n"
                        f"<i>–°—Ö–≤–∞—Ç–æ–∫</i>: <b>{step}</b>\n"
                        f"<i>–ß–∏—Å—Ç–∞—è –ø–æ–±–µ–¥–∞</i>: <b>{stats['wins']}</b>\n"
                        f"<i>–ß–∞—Å—Ç–∏—á–Ω—ã–π —É—Å–ø–µ—Ö</i>: <b>{stats['partial']}</b>\n"
                        f"<i>–ü–æ—Ä–∞–∂–µ–Ω–∏–µ</i>: <b>{stats['losses']}</b>\n\n"
                        f"{draw_phrase}",
                        parse_mode="HTML",
                        reply_markup=get_main_menu()
                    )
                await state.clear()
            elif fight_type == "timed":
                step += 1
                await state.update_data(step=step, score=score, stats=stats, is_fighting=True)
                control, attack = sequence[step-1]
                await state.update_data(current_move=(control, attack))
                fight_message = await callback.message.answer(
                    f"‚öîÔ∏è <code>–°—Ö–≤–∞—Ç–∫–∞ {step}</code>\n\n"
                    f"üéØ <i>–ö–æ–Ω—Ç—Ä–æ–ª—å</i>: <b>{control}</b>\n"
                    f"üí• <i>–ê—Ç–∞–∫–∞</i>: <b>{attack}</b>\n\n"
                    f"–í—ã–±–µ—Ä–∏ –∑–∞—â–∏—Ç—É (5 —Å–µ–∫):",
                    parse_mode="HTML",
                    reply_markup=get_fight_keyboard(is_timed=True)
                )
                await state.update_data(last_fight_message_id=fight_message.message_id)
                asyncio.create_task(timed_fight_timer(state, callback.message, callback.from_user.id, step, fight_message, fight_id))
            else:
                step += 1
                await state.update_data(step=step, score=score, stats=stats)
                control, attack = sequence[step-1]
                fight_message = await callback.message.answer(
                    f"‚öîÔ∏è <code>–°—Ö–≤–∞—Ç–∫–∞ {step} –∏–∑ 10</code>\n\n"
                    f"üéØ <i>–ö–æ–Ω—Ç—Ä–æ–ª—å</i>: <b>{control}</b>\n"
                    f"üí• <i>–ê—Ç–∞–∫–∞</i>: <b>{attack}</b>\n\n"
                    f"–í—ã–±–µ—Ä–∏ –∑–∞—â–∏—Ç—É:",
                    parse_mode="HTML",
                    reply_markup=get_fight_keyboard()
                )
                await state.update_data(last_fight_message_id=fight_message.message_id)
        finally:
            await state.update_data(is_processing=False)
        await callback.answer()

    @dp.callback_query(F.data == "hint")
    async def show_hint(callback: CallbackQuery, state: FSMContext):
        fight_data = await state.get_data()
        fight_id = fight_data.get("fight_id", "unknown")
        if fight_data.get("is_processing"):
            logger.info(f"Fight {fight_id}: Ignored duplicate hint callback from user {callback.from_user.id}")
            await callback.answer()
            return
        await state.update_data(is_processing=True)
        try:
            fight_type = fight_data.get("fight_type", "simple")
            step = fight_data.get("step", 1)
            stats = fight_data.get("stats", {"wins": 0, "partial": 0, "losses": 0, "hints": 0})
            last_fight_message_id = fight_data.get("last_fight_message_id")
            if fight_type != "simple":
                await callback.message.edit_text("–ü–æ–¥—Å–∫–∞–∑–∫–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –≤ —ç—Ç–æ–º —Ä–µ–∂–∏–º–µ!")
                await callback.answer()
                return
            stats["hints"] += 1
            await state.update_data(stats=stats)
            sequence = fight_data.get("fight_sequence", MOVES)
            control, attack = sequence[step-1]
            correct_defenses = [
                d for d, v in DEFENSE_MOVES.items()
                if control in v.get("control_defense", []) and attack in v.get("attack_defense", [])
            ]
            await callback.message.edit_text(
                f"‚öîÔ∏è <code>–°—Ö–≤–∞—Ç–∫–∞ {step} –∏–∑ 10</code>\n\n"
                f"üéØ <i>–ö–æ–Ω—Ç—Ä–æ–ª—å</i>: <b>{control}</b>\n"
                f"üí• <i>–ê—Ç–∞–∫–∞</i>: <b>{attack}</b>\n\n"
                f"üí° <i>–ü–æ–¥—Å–∫–∞–∑–∫–∞</i>: <b>{', '.join(correct_defenses) or '–Ω–µ—Ç –∑–∞—â–∏—Ç—ã'}</b>\n\n"
                f"–í—ã–±–µ—Ä–∏ –∑–∞—â–∏—Ç—É:",
                parse_mode="HTML",
                reply_markup=get_fight_keyboard()
            )
            if last_fight_message_id:
                if not await clear_keyboard(callback.message.bot, callback.message.chat.id, last_fight_message_id, fight_id):
                    await callback.message.answer("–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É.", reply_markup=get_main_menu())
                    await state.clear()
                    await callback.answer()
                    return
        finally:
            await state.update_data(is_processing=False)
        await callback.answer()

    @dp.callback_query(F.data == "show_profile")
    async def show_profile(callback: CallbackQuery, state: FSMContext):
        await callback.message.edit_text("üìä –ó–∞–≥—Ä—É–∂–∞—é –ø—Ä–æ—Ñ–∏–ª—å...", parse_mode="HTML")
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute(
                "SELECT fighter_name, life, strength, agility, spirit, belt "
                "FROM users_dev JOIN profiles_dev ON users_dev.user_id = profiles_dev.user_id "
                "WHERE users_dev.user_id = %s",
                (callback.from_user.id,)
            )
            result = cursor.fetchone()
            if result:
                name, life, strength, agility, spirit, belt = result
                await callback.message.edit_text(
                    f"üìä <b>–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å</b>\n"
                    f"–ò–º—è: <b>{name}</b>\n–ñ–∏–∑–Ω—å: <b>{life}</b> ‚ù§Ô∏è\n–°–∏–ª–∞: <b>{strength}</b> üí™\n"
                    f"–õ–æ–≤–∫–æ—Å—Ç—å: <b>{agility}</b> üåÄ\n–î—É—Ö: <b>{spirit}</b> ‚ú®\n–ü–æ—è—Å: <b>{belt}</b> üü°",
                    parse_mode="HTML",
                    reply_markup=get_profile_menu()
                )
            else:
                await callback.message.edit_text("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        except Exception as e:
            logger.error(f"Profile fetch failed: {e}")
            await callback.message.edit_text(f"–û—à–∏–±–∫–∞: {e}")
        finally:
            if conn:
                cursor.close()
                conn.close()
        await callback.answer()

    @dp.callback_query()
    async def debug_callback(callback: CallbackQuery):
        logger.info(f"Received callback: {callback.data} from {callback.from_user.id}")
        await callback.answer()
